import Foundation

/// Formats DiaryContent into final DiaryEntry
enum DiaryFormatter {
    /// Convert raw AI output to final diary entry
    static func format(_ content: DiaryContent) -> DiaryEntry {
        let cleanedMarkdown = postProcessMarkdown(content.rawMarkdown, date: content.date)
        return DiaryEntry(
            dateString: content.dateString,
            markdown: cleanedMarkdown,
            generatedAt: Date()
        )
    }

    /// Post-process markdown for proper formatting
    private static func postProcessMarkdown(_ markdown: String, date: Date) -> String {
        // Remove h1 headers from AI output
        var text = markdown.replacingOccurrences(of: #"^#\s+.+\n+"#, with: "", options: .regularExpression)
            .trimmingCharacters(in: .whitespacesAndNewlines)

        // First pass: remove empty lines between list items
        let initialLines = text.split(separator: "\n", omittingEmptySubsequences: false).map(String.init)
        var cleanedLines: [String] = []

        for (i, line) in initialLines.enumerated() {
            let prevLine = i > 0 ? initialLines[i - 1] : ""
            let nextLine = i < initialLines.count - 1 ? initialLines[i + 1] : ""

            let isListItem = { (s: String) -> Bool in
                s.hasPrefix("- ") || s.hasPrefix("  ")
            }

            if line.trimmingCharacters(in: .whitespaces).isEmpty &&
               isListItem(prevLine) &&
               isListItem(nextLine) {
                continue
            }

            cleanedLines.append(line)
        }

        // Second pass: ensure proper spacing around headings
        let lines = cleanedLines
        var result: [String] = []

        for (i, line) in lines.enumerated() {
            let prevLine = i > 0 ? lines[i - 1] : ""
            let nextLine = i < lines.count - 1 ? lines[i + 1] : ""

            if line.hasPrefix("##") && !prevLine.trimmingCharacters(in: .whitespaces).isEmpty {
                result.append("")
            }

            result.append(line)

            if line.hasPrefix("##") && !nextLine.trimmingCharacters(in: .whitespaces).isEmpty {
                result.append("")
            }

            if line.hasPrefix("- ") &&
               !prevLine.hasPrefix("- ") &&
               !prevLine.hasPrefix("  ") &&
               !prevLine.hasPrefix("##") &&
               !prevLine.trimmingCharacters(in: .whitespaces).isEmpty {
                result.insert("", at: result.count - 1)
            }

            if (line.hasPrefix("- ") || line.hasPrefix("  ")) &&
               !nextLine.hasPrefix("- ") &&
               !nextLine.hasPrefix("  ") &&
               !nextLine.trimmingCharacters(in: .whitespaces).isEmpty {
                result.append("")
            }
        }

        // Clean up multiple blank lines
        text = result.joined(separator: "\n")
            .replacingOccurrences(of: "\n{3,}", with: "\n\n", options: .regularExpression)
            .trimmingCharacters(in: .whitespacesAndNewlines)

        // Format date for header
        let formattedDate = DateFormatting.japaneseLong.string(from: date)

        return "# \(formattedDate)\n\n\(text)\n\n---\n\nGenerated by ccdiary\n"
    }
}
